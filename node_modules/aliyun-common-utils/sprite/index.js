'use strict';
var gradient = require('./gradient');
var Utils = require('bcore/utils');

var spriteDefaultOptions = {
  'isContinue': false,
  'type': 'radian',
  'drawN': 20,
  //
  'width': 100,
  'height': 100,
  //
  'color': {
    'from': 'rgba(0,150,150,0)',
    'to': 'rgba(250,250,250,1)',
    'space': 'rgb',
    'easing': 'linear.None.2'
  }
};

function sprite(options) {
  var canvas = document.createElement('canvas');
  canvas.width = options.width || options.w || options.size || options.radius * 2 || 80;
  canvas.height = options.height || options.h || options.size || options.radius * 2 || 80;
  var ctx = canvas.getContext('2d');
  return gradient(ctx, options).getCanvas();
  // if (typeof(type) === 'string') {
  //   switch (type) {
  //     case 'gradient':
  //       options = Utils.deepMerge(spriteDefaultOptions, options);
  //       break;
  //   }
  // }
}

var spriteCacheObejct = {};

function getSpriteKey(object) {
  var key = '';
  for (var k in object) {
    key += object[k];
  }
  var color = object.color;
  for(var i in color){
    key += color[i];
  }
  return key;
}

function getSprite(options, d) {
  if(typeof (options) === 'function') return options(d);
  if (options instanceof HTMLElement) return options; //入参本身是sprite
  options = Utils.deepMerge(spriteDefaultOptions, options);
  var key = getSpriteKey(options);
  if (spriteCacheObejct[key]) return spriteCacheObejct[key];
  return spriteCacheObejct[key] = sprite(options);
}


module.exports = {
  'gradient': gradient,
  'sprite': sprite,
  'getSprite': getSprite
};